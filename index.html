<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»™é˜¿æ¯›çš„ä¸“å±å¥‡å¦™ç©ºé—´ âœ¨</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: rgba(20, 20, 25, 0.7);
            --accent: #ff6b81; 
            --text: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-color);
            font-family: 'PingFang SC', 'Microsoft YaHei', 'Segoe UI', system-ui, sans-serif;
            color: var(--text);
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            display: block;
        }

        .input_video { display: none; }

        /* Modern UI Panel - LEFT SIDEBAR */
        .ui-panel {
            position: absolute;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            background: var(--panel-bg);
            padding: 30px 25px;
            border-radius: 24px;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 100;
            display: flex;
            flex-direction: column; 
            gap: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            width: 220px; 
        }

        .ui-panel.hidden {
            transform: translate(-150%, -50%);
            opacity: 0 !important;
            pointer-events: none;
        }

        .controls-row {
            display: flex;
            flex-direction: column; 
            gap: 15px;
            width: 100%;
        }

        button {
            width: 100%; 
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 14px 20px;
            border-radius: 16px; 
            cursor: pointer;
            font-size: 1.15rem; 
            letter-spacing: 1px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: left; 
        }

        button:hover, button.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent);
            transform: translateX(5px); 
        }

        .color-picker-wrapper {
            display: flex;
            flex-direction: column; 
            align-items: flex-start;
            gap: 15px;
            font-size: 1.1rem; 
            color: #ddd;
            background: rgba(0,0,0,0.3);
            padding: 20px 20px;
            border-radius: 16px;
            width: 100%;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            background: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; box-shadow: 0 0 8px rgba(255,255,255,0.4); }

        /* Premium Overlay for Permissions */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, rgba(30,30,40,0.9) 0%, rgba(5,5,5,0.95) 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(15px);
        }

        .card {
            background: rgba(255, 255, 255, 0.03);
            padding: 60px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            max-width: 800px;
        }

        #overlay h1 { 
            margin-bottom: 30px; 
            font-size: 3.5rem; 
            color: var(--accent); 
            text-shadow: 0 0 20px rgba(255, 107, 129, 0.4);
            letter-spacing: 2px;
        }
        
        #overlay p { 
            margin-bottom: 25px; 
            line-height: 1.8; 
            color: #e0e0e0; 
            font-size: 1.3rem; 
        }

        .guidelines {
            text-align: left;
            background: rgba(0,0,0,0.3);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 40px;
            font-size: 1.25rem; 
        }

        .guidelines li {
            list-style: none;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .start-btn {
            padding: 18px 50px;
            font-size: 1.5rem; 
            background: var(--accent);
            color: #fff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            letter-spacing: 1px;
            box-shadow: 0 0 25px rgba(255, 107, 129, 0.5);
            animation: pulse 2s infinite;
            text-align: center;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 25px rgba(255, 107, 129, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(255, 107, 129, 0.7); }
            100% { transform: scale(1); box-shadow: 0 0 25px rgba(255, 107, 129, 0.5); }
        }

        .status {
            position: absolute;
            top: 25px; right: 25px;
            background: rgba(0,0,0,0.4);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.1rem; 
            z-index: 100;
            color: #bbb;
            border: 1px solid rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
        }
        .status span { color: var(--accent); font-weight: bold; margin-left: 5px; }

        .toggle-ui-btn {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 105;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 12px 20px;
            font-size: 1.1rem;
            border-radius: 30px;
            color: #fff;
            cursor: pointer;
            opacity: 0; 
            pointer-events: none;
            transition: all 0.3s ease;
        }
        .toggle-ui-btn:hover {
            background: rgba(255,255,255,0.15);
        }

        /* ========================================== */
        /* MOBILE RESPONSIVE DESIGN (For Phones)      */
        /* ========================================== */
        @media (max-width: 768px) {
            .card { padding: 30px 20px; }
            #overlay h1 { font-size: 2.2rem; margin-bottom: 15px; }
            #overlay p { font-size: 1rem; margin-bottom: 15px; }
            .guidelines { font-size: 1rem; padding: 15px; margin-bottom: 25px; }
            .start-btn { font-size: 1.2rem; padding: 12px 30px; }

            .status { top: 15px; right: 15px; font-size: 0.85rem; padding: 10px 15px; }
            .toggle-ui-btn { bottom: 15px; left: 15px; font-size: 0.9rem; padding: 10px 15px; }

            .ui-panel {
                top: auto;
                bottom: 70px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                padding: 15px;
                flex-direction: column;
                gap: 15px;
            }
            
            .ui-panel.hidden {
                transform: translate(-50%, 150px); 
            }

            .controls-row {
                flex-direction: row;
                flex-wrap: nowrap;
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 5px;
            }
            
            button {
                width: auto;
                white-space: nowrap;
                font-size: 1rem;
                padding: 10px 16px;
            }

            .color-picker-wrapper {
                flex-direction: row;
                justify-content: space-between;
                font-size: 1rem;
                padding: 10px 15px;
            }
        }

    </style>
</head>
<body>

    <audio id="bgMusic" src="backgroundmusic.mp3" loop></audio>

    <div id="overlay">
        <div class="card">
            <h1>ç”Ÿæ—¥å¿«ä¹ï¼Œé˜¿æ¯›ï¼ğŸ‚</h1>
            <p>è¿™æ˜¯ä¸€ä»½ä¸ºä½ ç‰¹åˆ«å‡†å¤‡çš„é­”æ³•ç¤¼ç‰©ã€‚åœ¨å¼€å§‹ä¹‹å‰ï¼Œå®ƒéœ€è¦å€ŸåŠ©ä½ çš„<b>æ‘„åƒå¤´</b>æ¥æ„Ÿå—ä½ çš„åŠ¨ä½œã€‚</p>
            
            <div class="guidelines">
                <li>âœ‹ <b>å¼ å¼€æˆ–æ¡ç´§åŒæ‰‹</b>ï¼šæ§åˆ¶ç²’å­çš„æ•£å¼€ä¸èšæ‹¢</li>
                <li>ğŸ‘‹ <b>åœ¨é•œå¤´å‰ç§»åŠ¨åŒæ‰‹</b>ï¼šå¯ä»¥å…¨æ–¹ä½æ—‹è½¬æŸ¥çœ‹å›¾å½¢</li>
                <li>ğŸµ <b>æ‰“å¼€å£°éŸ³</b>ï¼šä¼´éšä¸“å±èƒŒæ™¯éŸ³ä¹ï¼Œäº«å—è¿™åœºè§†è§‰ç››å®´ï¼</li>
            </div>

            <button class="start-btn" id="startBtn">å¼€å¯é­”æ³•ç©ºé—´</button>
            <p id="errorMsg" style="color: #ff6b81; margin-top: 20px; display: none; font-size: 1.1rem;"></p>
        </div>
    </div>

    <div class="status">
        æ£€æµ‹åˆ°æ‰‹éƒ¨: <span id="handStatus">0 åª</span>
    </div>

    <button class="toggle-ui-btn" id="toggleUiBtn">ğŸ‘ï¸ éšè—æ§åˆ¶å°</button>

    <div class="ui-panel" id="uiPanel" style="opacity: 0; pointer-events: none;">
        <div class="controls-row">
            <button class="shape-btn active" data-shape="cake">ğŸ‚ ç”Ÿæ—¥è›‹ç³•</button>
            <button class="shape-btn" data-shape="heart">ğŸ’– ä¸“å±çˆ±å¿ƒ</button>
            <button class="shape-btn" data-shape="fireworks">ğŸ‡ ç»šä¸½çƒŸèŠ±</button>
            <button class="shape-btn" data-shape="flower">ğŸŒ¸ ç»½æ”¾èŠ±æœµ</button>
            <button class="shape-btn" data-shape="saturn">ğŸª æµ©ç€šæ˜Ÿç©º</button>
        </div>
        <div class="color-picker-wrapper">
            <span>ğŸ¨ ç²’å­é¢œè‰²ï¼š</span>
            <input type="color" id="colorPicker" value="#ff6b81">
        </div>
    </div>
    
    <video class="input_video" autoplay playsinline></video>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ==========================================
        // CONFIGURATION & VARIABLES
        // ==========================================
        const PARTICLE_COUNT = 25000;
        let particles;
        let geometry;
        let basePositions = new Float32Array(PARTICLE_COUNT * 3);
        let currentPositions = new Float32Array(PARTICLE_COUNT * 3);
        let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        let baseColorHex = 0xff6b81; 
        let handTension = 0; 
        let smoothedTension = 0;
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.05);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- SHAPE GENERATORS ---
        const Shapes = {
            cake: (i, t) => {
                const layer = Math.floor(Math.random() * 3);
                const radius = 2 - (layer * 0.4);
                const height = -1.5 + (layer * 1.2) + (Math.random() * 1.0);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * radius;
                return { x: Math.cos(angle) * r, y: height, z: Math.sin(angle) * r };
            },
            heart: (i, t) => {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random();
                const x = 16 * Math.pow(Math.sin(angle), 3);
                const y = 13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle);
                const z = (Math.random() - 0.5) * 4;
                return { x: x * 0.15 * r, y: y * 0.15 * r, z: z * r };
            },
            fireworks: (i, t) => {
                const u = Math.random();
                const v = Math.random();
                const theta = u * 2.0 * Math.PI;
                const phi = Math.acos(2.0 * v - 1.0);
                const r = Math.cbrt(Math.random()) * 4;
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            },
            flower: (i, t) => {
                const theta = Math.random() * Math.PI * 2;
                const k = 5; 
                const r = Math.cos(k * theta) * 3 * Math.random();
                return { x: Math.cos(theta) * r, y: (Math.random()-0.5), z: Math.sin(theta) * r };
            },
            saturn: (i, t) => {
                if (Math.random() > 0.6) {
                    const u = Math.random(), v = Math.random();
                    const theta = u * 2.0 * Math.PI, phi = Math.acos(2.0 * v - 1.0);
                    const r = 1.5 * Math.cbrt(Math.random());
                    return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 2.0 + Math.random() * 2.0;
                    return { x: Math.cos(angle) * r, y: (Math.random() - 0.5) * 0.2, z: Math.sin(angle) * r };
                }
            }
        };

        // Initialize Particles
        function initParticles() {
            geometry = new THREE.BufferGeometry();
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = Shapes['cake'](i, PARTICLE_COUNT);
                targetPositions[i * 3] = pos.x;
                targetPositions[i * 3 + 1] = pos.y;
                targetPositions[i * 3 + 2] = pos.z;
                
                currentPositions[i * 3] = pos.x * 3;
                currentPositions[i * 3 + 1] = pos.y * 3;
                currentPositions[i * 3 + 2] = pos.z * 3;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            updateColors(baseColorHex);

            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(8, 8, 0, 8, 8, 8);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 16, 16);
            const texture = new THREE.CanvasTexture(canvas);

            const material = new THREE.PointsMaterial({
                size: 0.12,
                vertexColors: true,
                map: texture,
                transparent: true,
                opacity: 0.85,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            particles.position.y = 0; 
            scene.add(particles);
        }

        function changeShape(shapeName) {
            const generator = Shapes[shapeName];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = generator(i, PARTICLE_COUNT);
                targetPositions[i * 3] = pos.x;
                targetPositions[i * 3 + 1] = pos.y;
                targetPositions[i * 3 + 2] = pos.z;
            }
        }

        function updateColors(hexColor) {
            const color = new THREE.Color(hexColor);
            const colorAttr = geometry.attributes.color;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = color.r * (0.6 + Math.random() * 0.4);
                const g = color.g * (0.6 + Math.random() * 0.4);
                const b = color.b * (0.6 + Math.random() * 0.4);
                colorAttr.setXYZ(i, r, g, b);
            }
            colorAttr.needsUpdate = true;
            document.documentElement.style.setProperty('--accent', hexColor);
        }

        // ==========================================
        // HAND TRACKING 
        // ==========================================
        const videoElement = document.querySelector('.input_video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        function calculateHandTension(landmarks) {
            const wrist = landmarks[0];
            const tips = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]]; 
            let totalDist = 0;
            tips.forEach(tip => {
                const dx = tip.x - wrist.x;
                const dy = tip.y - wrist.y;
                totalDist += Math.sqrt(dx*dx + dy*dy);
            });
            const avgDist = totalDist / 4;
            return Math.max(0, Math.min(1, (avgDist - 0.15) * 3.3));
        }

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('handStatus').innerText = `${results.multiHandLandmarks.length} åª`;
                
                let totalTension = 0;
                let centerX = 0, centerY = 0;

                results.multiHandLandmarks.forEach(landmarks => {
                    totalTension += calculateHandTension(landmarks);
                    centerX += landmarks[0].x;
                    centerY += landmarks[0].y;
                });

                handTension = totalTension / results.multiHandLandmarks.length;
                
                centerX /= results.multiHandLandmarks.length;
                centerY /= results.multiHandLandmarks.length;
                
                targetRotation.y = (centerX - 0.5) * 4;
                targetRotation.x = (centerY - 0.5) * 2;

            } else {
                document.getElementById('handStatus').innerText = "0 åª";
                handTension = 0; 
                targetRotation.y = 0;
                targetRotation.x = 0;
            }
        });

        // ==========================================
        // INITIALIZATION & UI EVENTS
        // ==========================================
        document.getElementById('startBtn').addEventListener('click', async () => {
            const btn = document.getElementById('startBtn');
            const errorMsg = document.getElementById('errorMsg');
            btn.innerText = "æ­£åœ¨è¿æ¥é­”æ³•...";
            
            try {
                // Play Background Music
                const bgMusic = document.getElementById('bgMusic');
                bgMusic.volume = 0.5; // Set volume to 50%
                bgMusic.play().catch(e => console.log("éŸ³ä¹æ’­æ”¾å¤±è´¥ (å¯èƒ½æ˜¯æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾é™åˆ¶):", e));

                // Start Camera
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                await videoElement.play();
                
                await hands.send({ image: videoElement }); 

                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({ image: videoElement }); },
                    width: 640, height: 480
                });
                cameraUtils.start();

                // UI Transitions
                document.getElementById('overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('overlay').style.display = 'none', 800);
                
                document.getElementById('uiPanel').style.opacity = '1';
                document.getElementById('uiPanel').style.pointerEvents = 'all';
                
                document.getElementById('toggleUiBtn').style.opacity = '1';
                document.getElementById('toggleUiBtn').style.pointerEvents = 'all';

                initParticles();
                animate();

            } catch (err) {
                console.error(err);
                btn.innerText = "é‡è¯•ä¸€æ¬¡";
                errorMsg.innerText = "å“å‘€ï¼è¯·ç¡®ä¿å…è®¸æµè§ˆå™¨ä½¿ç”¨æ‘„åƒå¤´å“¦ã€‚";
                errorMsg.style.display = 'block';
            }
        });
        
        // Hide/Show UI Button Logic
        document.getElementById('toggleUiBtn').addEventListener('click', (e) => {
            const panel = document.getElementById('uiPanel');
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                e.target.innerText = 'ğŸ‘ï¸ éšè—æ§åˆ¶å°';
            } else {
                panel.classList.add('hidden');
                e.target.innerText = 'ğŸ‘ï¸ æ˜¾ç¤ºæ§åˆ¶å°';
            }
        });

        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                changeShape(e.target.dataset.shape);
            });
        });

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            updateColors(e.target.value);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==========================================
        // MAIN ANIMATION LOOP
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);

            smoothedTension += (handTension - smoothedTension) * 0.1;
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            if (particles) {
                particles.rotation.x = currentRotation.x;
                particles.rotation.y = currentRotation.y;
                if(smoothedTension === 0 && targetRotation.y === 0) particles.rotation.y += 0.003; 

                const positions = particles.geometry.attributes.position.array;
                const totalScale = 1.0 + (smoothedTension * 1.5); 

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const idx = i * 3;
                    
                    basePositions[idx] += (targetPositions[idx] - basePositions[idx]) * 0.04;
                    basePositions[idx+1] += (targetPositions[idx+1] - basePositions[idx+1]) * 0.04;
                    basePositions[idx+2] += (targetPositions[idx+2] - basePositions[idx+2]) * 0.04;

                    positions[idx] = basePositions[idx] * totalScale;
                    positions[idx+1] = basePositions[idx+1] * totalScale;
                    positions[idx+2] = basePositions[idx+2] * totalScale;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
